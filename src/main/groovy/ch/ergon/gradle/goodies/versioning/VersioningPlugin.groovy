/*
* Copyright (c) Ergon Informatik AG, Switzerland
*/
package ch.ergon.gradle.goodies.versioning


import org.gradle.api.Action
import org.gradle.api.Plugin
import org.gradle.api.Project

/**
* Nice and concise versioning of your artifacts using git describe and your git tags.
*/
class VersioningPlugin implements Plugin<Project> {

	/**
	* Generate a file that describes the project version including tags and hashes and when
	* it was built where, on which operating system with what jdk.
	**/
	def generateVersionPropertiesFile(Project project, String versioningFolder) {
		def longVersion = figureOutLongVersion(project)
		def hostInfo = "${System.getProperty("os.name")} - ${System.getProperty("os.arch")} - ${System.getProperty("os.version")}"
		def javaVersion = System.getProperty("java.version")
		def javaVmVendor = System.getProperty("java.vm.vendor")

		def content = """
		# File generated by build.
		build.host=${hostInfo}
		build.java.version=${javaVersion}
		build.java.vm.vendor=${javaVmVendor}
		build.artifact-id=${project.name}
		build.version=${longVersion}
		""".stripIndent()

		new File(versioningFolder).mkdirs()
		def versionsFile = new File(versioningFolder, "version.properties")
		versionsFile.text = content
	}

	/*
	* Properties that should be used to determine up-to-dateness.
	*/

	def versionProperties(Project project) {
		def props = [
			longVersion : figureOutLongVersion(project),
			hostInfo    : "${System.getProperty("os.name")} - ${System.getProperty("os.arch")} - ${System.getProperty("os.version")}",
			javaVersion : System.getProperty("java.version"),
			javaVmVendor: System.getProperty("java.vm.vendor"),
			artifact_id : project.name
		]
		project.logger.info("version properties input props: $props")
		return props
	}

	def figureOutLongVersion(Project project) {
		return project.versioning.describeLongVersion()
	}

	/**
	* Will be executed when java, groovy or scala plugin is applied.
	*/
	class ConfigureProjectWithSourceSet implements Action<Plugin> {
		Project project

		def generateVersionPropertiesTaskName = 'generateVersionProperties'

		@Override
		void execute(Plugin plugin) {
			def versioningFolder = "${project.buildDir}/versioning-data/"
			project.sourceSets.main.output.dir(versioningFolder, builtBy: 'generateVersionProperties')

			if (project.tasks.findByName(generateVersionPropertiesTaskName) == null) {
				project.task(
						group: 'versioning',
						description: 'Generate a version.properties file in ${versioningFolder} that identifies this version.',
						generateVersionPropertiesTaskName) {
							// foo is necessary here, so the groovy compiler knows this is a closure and not a block.
							{ foo -> inputs.properties(versionProperties()) }
							outputs.dir versioningFolder

							doLast { generateVersionPropertiesFile(project, versioningFolder) }
						}
			}
		}
	}

	@Override
	void apply(Project project) {
		project.getExtensions().create('versioning', VersioningExtension, project)
		def configureProjectWithSourceSet = new ConfigureProjectWithSourceSet(project: project)

		// trigger on plugins with source sets
		[
			'scala',
			'groovy',
			'kotlin',
			'java'
		].each { id ->
			project.plugins.withId(id, configureProjectWithSourceSet)
		}
		project.task(
				group: 'versioning',
				description: 'Output the version that would be used when building.',
				'describeVersion')
		{
			doLast { println "The current version is: ${project.version}" }
		}
		// print version when installing or uploading
		def describeVersion = project.tasks.findByName('describeVersion')
		project.tasks.findByName('install')?.dependsOn(describeVersion)
		project.tasks.findByName('uploadArchives')?.dependsOn(describeVersion)

		// now define the version, after we read all the config.
		project.afterEvaluate {
			def version = project.versioning.describeVersion()
			project.logger.info("Project version is: $version")
			project.version = version

			project.ext.versionNumber = project.versioning.versionNumber()
		}
	}
}